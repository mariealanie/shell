# shell Командный интерпретатор.

**Реализовать под управлением ОС Unix интерактивный КИ (некоторый аналог shell), осуществляющий в цикле:**

- считывание командной строки со стандартного ввода,
- анализ считанной строки
- исполнение соответствующих действий.
 
**В командной строке могут присутствовать следующие операции:**
(указаны в порядке убывания приоритетов, на одной строке приоритет одинаков)

| , > , >> , <
&& , ||
; , &

Допустимы также круглые скобки, позволяющие изменить порядок выполнения операций. Для выполнения команды в скобках создаётся отдельный экземпляр КИ.

В командной строке допустимо произвольное количество пробелов между составляющими ее словами.

**Обозначения:**

Int_Com - Команда КИ
CondCom - Команда с условным выполнением
Com – Команда
​SimpleCom – Простая команда
​InOutChange – Перенаправление ввода-вывода
InChange – Перенаправление ввода
OutChange – Перенаправление вывода
Pipeline – Конвейер

# Синтаксис командной строкики:

< Int_Com > → < CondCom >{ [ ; | & ] < Int_Com >}{ ; | &}

< CondCom > → < Com >{ [&& | || ] } < CondCom >

< Com > → {< InOutChang>}<Pipeline> | <Pipeline> {< InOutChang>} | ( < Int_Com >)

< InOutChang> → { < InChang>}< OutChang> | {< OutChang>} < InChang>

< InChang> → ‘<’ <имя_файла>

< OutChang>→ ‘>’ <имя_файла> | ‘>>’ <имя_файла>

< Pipeline>→ < SimpleCom >{‘|’ <Pipeline>}

< SimpleCom > → <имя команды><список аргументов>

Замечания по нотации синтаксиса:
• {X} – означает, что X может отсутствовать;
• [x | y] – значит, что должен присутствовать один из вариантов : x либо y
• | - в описании правил то же, что «ИЛИ»
pr1 | …| prN – конвейер: стандартный вывод всех команд, кроме последней, направляется на стандартный ввод следующей команды конвейера. Каждая команда выполняется как самостоятельный процесс (т.е. все pri выполняются параллельно). КИ ожидает завершения последней команды. Код завершения конвейера = код завершения последней команды конвейера.

Простую команду можно рассматривать как частный случай конвейера.

com1 ; com2 – означает, что команды будут выполняться последовательно

com & - запуск команды в фоновом режиме (т.е. КИ готов к вводу следующей команды, не ожидая завершения данной команды com, а com не реагирует на сигналы завершения, посылаемые с клавиатуры, например, на нажатие Ctrl-C ). После завершения выполнения фоновой команды не должно остаться процесса – зомби.

Посмотреть список работающих процессов можно с помощью команды ps.

com1 && com2 - выполнить com1, если она завершилась успешно, выполнить com2;
com1 || com2 - выполнить com1, если она завершилась неуспешно, выполнить com2.
Должен быть проверен и системный успех и значение, возвращенное exit ( 0 – успех).

# Перенаправление ввода-вывода :

< <имя_файла> - файл используется в качестве стандартного ввода;

> <имя_файла> - стандартный вывод направляется в файл (если файла не было - он создается, если файл уже существовал, то его старое содержимое отбрасывается, т.е. происходит вывод с перезаписью);

>> <имя_файла> – стандартный вывод направляется в файл ( если файла не было - он создается, если файл уже существовал, то его старое содержимое сохраняется, а запись производится в конец файла)

# Моделирование фонового режима.

**Основные требования, которым должен удовлетворять фоновый процесс в вашей программе**:

• Он должен работать параллельно с основной программой. После запуска фонового процесса КИ может запускать на выполнение следующую команду, не дожидаясь, пока фоновый процесс закончит работу.
• Он не должен реагировать на сигналы, приходящие с клавиатуры. Вообще таких сигналов несколько, но в вашей программе достаточно не реагировать на SIGINT (сигнал, который вызывается нажатием Ctrl-C). Сигналы с клавиатуры получают только процессы основной (не фоновой) группы. Они завершаются, а фоновые процессы продолжают работать.
• Фоновый процесс не имеет доступа к терминалу, т.е. не должен читать со стандартного ввода (это достигается перенаправлением стандартного ввода на файл устройства /dev/null, чтение из которого сразу дает EOF). Вывод на экран можно разрешить, а можно и запретить, перенаправив стандартный вывод на тот же /dev/null (вывод будет просто пропадать).
• После завершения фонового процесса не должно остаться процесса «зомби». А его не остается либо, когда родительский процесс завершается раньше, чем «сын», либо, когда в родительском процессе вызывается функция wait или waitpid.
• После завершения фонового процесса КИ должен выдать в стандартный канал вывода сообщения вида:
Process PID exited with code CODE
или в случае аварийного завершения
 Process PID aborted by signal SIGNAL
Здесь ​PID – идентификатор завершившегося процесса,
CODE – код завершения процесса (можно узнать, используя макрос WEXITCODE), SIGNAL – номер сигнала, по которому аварийно завершился процесс (можно узнать, используя макрос WTERMSIG)
 

**Схема моделирования фонового режима**

Процесс, созданный для запуска фоновой команды:

- перенаправляет стандартный ввод на файл “/dev/null” – теперь при попытке чтения со стандартного ввода сразу будет получен конец файла, так что не будет конфликта чтения между основным процессом и фоновым;

- вывод тоже можно перенаправить на “/dev/null”, тогда он будет просто пропадать, но можно и оставить для отладки;

- устанавливает игнорирование сигнала SIGINT ( signal (SIGINT, SIG_IGN) );

- запускает на выполнение собственно фоновый процесс.

Чтобы не оставалось процесса-«зомби», а также для получения информации о PID, CODE или SIGNAL завершившегося процесса (см. выше), можно использовать системный вызов  waitpid без блокирования нужное количество раз, например, перед вводом очередной команды или при получении сигнала SIGCHLD
